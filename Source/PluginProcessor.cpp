/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
MumuAudioFlangerAudioProcessor::MumuAudioFlangerAudioProcessor() : m_knob1(0),
                                                                   m_knob2(0),
                                                                   m_knob3(0),
                                                                   m_windowParam(0),
                                                                   button1(1),
                                                                   button2(0)
{
    
    m_fDelayTime = 0.1;
    m_fFeedback = 0.5;
    m_fWetLevel = m_knob3;
    
    FourPDelayL = FourPointDelay();
    FourPDelayL.setMaxDelay(m_sampleRate, 1.0);
    FourPDelayL.setDelayTime(m_sampleRate, m_fDelayTime);
    FourPDelayL.setWetMix(m_fWetLevel);
    FourPDelayL.setFeedback(m_fFeedback);
    FourPDelayL.setPlayheads();
    
    FourPDelayR = FourPointDelay();
    FourPDelayR.setMaxDelay(m_sampleRate, 1.0);
    FourPDelayR.setDelayTime(m_sampleRate, m_fDelayTime);
    FourPDelayR.setWetMix(m_fWetLevel);
    FourPDelayR.setFeedback(m_fFeedback);
    FourPDelayR.setPlayheads();
    
    SineLFOL = SineLFO();
    SineLFOR = SineLFO();
    
    TriLFOL = TriLFO();
    TriLFOR = TriLFO();
    
    m_LPF_Left.flushDelays();
    m_LPF_Right.flushDelays();
    
    m_HPF_Left.flushDelays();
    m_HPF_Right.flushDelays();
    
    
    
    
    
    
}

MumuAudioFlangerAudioProcessor::~MumuAudioFlangerAudioProcessor()
{
}

//==============================================================================
const String MumuAudioFlangerAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

int MumuAudioFlangerAudioProcessor::getNumParameters()
{
    return totalNumParams;
}

float MumuAudioFlangerAudioProcessor::getParameter (int index)
{
    switch (index) {
        case knob1Param: return m_knob1;
        case knob2Param: return m_knob2;
        case knob3Param: return m_knob3;
        case knob4Param: return m_knob4;
        case button1Param: return button1;
        case button2Param: return button2;
        case windowComponentParam: return m_windowParam;
        default: return 0.0;
    }
}

void MumuAudioFlangerAudioProcessor::setParameter (int index, float newValue)
{
    switch (index) {
            //Rate
        case knob1Param: m_knob1 = newValue;
            m_fLFORate = mapFunc(m_knob1,0,1,0.01,4);
            SineLFOL.setFrequency(m_fLFORate);
            SineLFOR.setFrequency(m_fLFORate);
            TriLFOL.setFrequency(m_fLFORate);
            TriLFOR.setFrequency(m_fLFORate);break;
            //Mod Depth
        case knob2Param: m_knob2 = newValue;
            m_fModDepth = mapFunc(m_knob2, 0, 1, 0.001, 0.015);
            break;
            //Mix Knob
        case knob3Param: m_knob3 = newValue;
            m_fWetLevel = m_knob3;
            FourPDelayL.setWetMix(m_fWetLevel);
            FourPDelayR.setWetMix(m_fWetLevel); break;
        case knob4Param: m_knob4 = newValue;
            m_fFeedback = mapFunc(m_knob4, 0, 1, -.98, 0.98);;
            FourPDelayL.setFeedback(m_fFeedback);
            FourPDelayR.setFeedback(m_fFeedback); break;
            //Button
        case button1Param: button1 = newValue; break;
        case button2Param: button2 = newValue; break;
            
        case windowComponentParam: m_windowParam = newValue; break;
        default: break;
    }
}

const String MumuAudioFlangerAudioProcessor::getParameterName (int index)
{
    switch (index){
        case knob1Param: return "Mod Rate";
        case knob2Param: return "Mod Depth";
        case knob3Param: return "Dry / Wet";
        case knob4Param: return "Feedback";
        case button1Param: return "Sine Mod";
        case button2Param: return "Tri Mod";
        case windowComponentParam: return "Window Param";
        default: return String::empty;
    }
}

const String MumuAudioFlangerAudioProcessor::getParameterText (int index)
{
    return String(getParameter(index),2);
}

const String MumuAudioFlangerAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String MumuAudioFlangerAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool MumuAudioFlangerAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool MumuAudioFlangerAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool MumuAudioFlangerAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool MumuAudioFlangerAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool MumuAudioFlangerAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double MumuAudioFlangerAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int MumuAudioFlangerAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MumuAudioFlangerAudioProcessor::getCurrentProgram()
{
    return 0;
}

void MumuAudioFlangerAudioProcessor::setCurrentProgram (int index)
{
}

const String MumuAudioFlangerAudioProcessor::getProgramName (int index)
{
    return String();
}

void MumuAudioFlangerAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void MumuAudioFlangerAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    
    m_sampleRate = sampleRate;
    
    m_fLFORate = mapFunc(m_knob1,0,1,0.01,4);
    m_fModDepth = mapFunc(m_knob2, 0, 1, 0.001, 0.015);
    m_fWetLevel = m_knob3;
    m_fFeedback = mapFunc(m_knob4,0,1,-.985,.985);
    
    FourPDelayL.setMaxDelay(m_sampleRate, 0.5);
    FourPDelayL.setDelayTime(m_sampleRate, m_fDelayTime);
    FourPDelayL.setWetMix(m_fWetLevel);
    FourPDelayL.setFeedback(m_fFeedback);
    FourPDelayL.prepareToPlay();
    FourPDelayL.setPlayheads();
    
    FourPDelayR.setMaxDelay(m_sampleRate, 0.5);
    FourPDelayR.setDelayTime(m_sampleRate, m_fDelayTime);
    FourPDelayR.setWetMix(m_fWetLevel);
    FourPDelayR.setFeedback(m_fFeedback);
    FourPDelayR.prepareToPlay();
    FourPDelayR.setPlayheads();
    
    SineLFOL.setPhase(0);
    SineLFOL.setFrequency(m_fLFORate);
    SineLFOL.setSampleRate(m_sampleRate);
    
    SineLFOR.setPhase(0);
    SineLFOR.setFrequency(m_fLFORate);
    SineLFOR.setSampleRate(m_sampleRate);
    
    TriLFOL.setPhase(0);
    TriLFOL.setFrequency(m_fLFORate);
    TriLFOL.setSampleRate(m_sampleRate);
    
    TriLFOR.setPhase(0);
    TriLFOR.setFrequency(m_fLFORate);
    TriLFOR.setSampleRate(m_sampleRate);
    
    m_LPF_Left.flushDelays();
    m_LPF_Right.flushDelays();
    calculateLPFCoeffs(600, m_sampleRate);
    
    m_HPF_Left.flushDelays();
    m_HPF_Right.flushDelays();
    calculateHPFCoeffs(600, m_sampleRate);
    
    
}

void MumuAudioFlangerAudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
    sendChangeMessage();
}

void MumuAudioFlangerAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    //Get BPM/////////////////
    AudioPlayHead::CurrentPositionInfo pos; //temp position to store current ops
    
    //If playhead is active then store its position info in temporary position object
    if (getPlayHead() != nullptr && getPlayHead()->getCurrentPosition(pos)){
        // If our BPM has changed, print our bpm
        if (pos.bpm != lastPosInfo.bpm) {
            //std::cout << pos.bpm << std::endl;
        }
        lastPosInfo = pos;
    }
    ///////////////////////////
    
    // In case we have more outputs than inputs, this code clears any output
    // channels that didn't contain input data, (because these aren't
    // guaranteed to be empty - they may contain garbage).
    // I've added this to avoid people getting screaming feedback
    // when they first compile the plugin, but obviously you don't need to
    // this code if your algorithm already fills all the output channels.
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());

    // This is the place where you'd normally do the guts of your plugin's
    // audio processing...
    
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);
        m_bufferSize = buffer.getNumSamples();

        for ( int i = 0; i < buffer.getNumSamples(); i++ )
        {
            if(channel == 0)
            {
                float lfoValue = 0;
                
                if (button1 == 1)
                {
                    lfoValue = SineLFOL.calcSineLFO(centerValue, m_fModDepth);
                }
                
                if (button2 == 1)
                {
                    lfoValue = TriLFOL.calcTriLFO(centerValue, m_fModDepth);
                }
                
                FourPDelayL.setDelayTime(m_sampleRate, lfoValue);
                FourPDelayL.setPlayheads();
                channelData[i] = FourPDelayL.process(channelData[i]);
                
                channelData[i] = (m_HPF_Left.doBiQuad(channelData[i]) * -1) + m_LPF_Left.doBiQuad(channelData[i]);
            }
            else if(channel == 1)
            {
                float lfoValue = 0;
                
                if (button1 == 1)
                {
                    lfoValue = SineLFOR.calcSineLFO(centerValue, m_fModDepth);
                }
                
                if (button2 == 1)
                {
                    lfoValue = TriLFOR.calcTriLFO(centerValue, m_fModDepth);
                }

                FourPDelayR.setDelayTime(m_sampleRate, lfoValue);
                FourPDelayR.setPlayheads();
                channelData[i] = FourPDelayR.process(channelData[i]);

                channelData[i] = (m_HPF_Right.doBiQuad(channelData[i]) * -1) + m_LPF_Right.doBiQuad(channelData[i]);
            }
        }
     }
    
    currentSampleBuffer = buffer;
    sendChangeMessage();

}

//==============================================================================
bool MumuAudioFlangerAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* MumuAudioFlangerAudioProcessor::createEditor()
{
    return new MumuAudioFlangerAudioProcessorEditor (*this);
}

//==============================================================================
void MumuAudioFlangerAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void MumuAudioFlangerAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MumuAudioFlangerAudioProcessor();
}

void MumuAudioFlangerAudioProcessor::calculateLPFCoeffs(float fCuttoffFreq, float sampleRate)
{
    //This is LinkWitz Riley Lowpass
    float omega_c = M_PI * fCuttoffFreq;
    float theta_c = M_PI * fCuttoffFreq /sampleRate;
    
    float k = omega_c/tan(theta_c);
    float k_squared = k*k;
    
    float omega_c_squared = omega_c*omega_c;
    
    float fDenominator = k_squared + omega_c_squared + 2.0*k*omega_c;
    
    float fb1_Num = -2.0*k_squared + 2.0*omega_c_squared;
    float fb2_Num = -2.0*k*omega_c + k_squared + omega_c_squared;
    
    float a0 = omega_c_squared/fDenominator;
    float a1 = 2.0*omega_c_squared/fDenominator;
    float a2 = a0;
    float b1 = fb1_Num/fDenominator;
    float b2 = fb2_Num/fDenominator;
    
    m_LPF_Left.m_f_a0 = a0;
    m_LPF_Left.m_f_a1 = a1;
    m_LPF_Left.m_f_a2 = a2;
    m_LPF_Left.m_f_b1 = b1;
    m_LPF_Left.m_f_b2 = b2;
    
    m_LPF_Right.m_f_a0 = a0;
    m_LPF_Right.m_f_a1 = a1;
    m_LPF_Right.m_f_a2 = a2;
    m_LPF_Right.m_f_b1 = b1;
    m_LPF_Right.m_f_b2 = b2;
}

void MumuAudioFlangerAudioProcessor::calculateHPFCoeffs(float fCuttoffFreq, float sampleRate)
{
    //This is Linkwitz Riley Highpass
    float omega_c = M_PI * fCuttoffFreq;
    float theta_c = M_PI * fCuttoffFreq / sampleRate;
    
    float k = omega_c/tan(theta_c);
    float k_squared = k*k;
    
    float omega_c_squared = omega_c*omega_c;
    
    float fDenominator = k_squared + omega_c_squared + 2.0*k*omega_c;
    
    float fb1_Num = -2.0*k_squared + 2.0*omega_c_squared;
    float fb2_Num = -2.0*k*omega_c + k_squared + omega_c_squared;
    
    float a0 = k_squared/fDenominator;
    float a1 = -2.0*k_squared/fDenominator;
    float a2 = a0;
    float b1 = fb1_Num/fDenominator;
    float b2 = fb2_Num/fDenominator;
    
    m_HPF_Left.m_f_a0 = a0;
    m_HPF_Left.m_f_a1 = a1;
    m_HPF_Left.m_f_a2 = a2;
    m_HPF_Left.m_f_b1 = b1;
    m_HPF_Left.m_f_b2 = b2;
    
    m_HPF_Right.m_f_a0 = a0;
    m_HPF_Right.m_f_a1 = a1;
    m_HPF_Right.m_f_a2 = a2;
    m_HPF_Right.m_f_b1 = b1;
    m_HPF_Right.m_f_b2 = b2;
    
}


